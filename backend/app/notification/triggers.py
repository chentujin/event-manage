"""
通知触发器
处理系统事件并发送相应的通知
"""
from typing import Dict, Any, List\nfrom app import db\nfrom app.models import (\n    NotificationRule, NotificationTemplate, NotificationLog,\n    User, UserNotificationPreference, Incident, Problem\n)\nfrom app.notification.service import get_notification_service\nimport logging\nimport json\n\nlogger = logging.getLogger(__name__)\n\nclass NotificationTrigger:\n    \"\"\"通知触发器类\"\"\"\n    \n    def __init__(self):\n        self.notification_service = get_notification_service()\n    \n    def trigger_event(self, event_type: str, record_id: int, context: Dict[str, Any]):\n        \"\"\"触发事件通知\"\"\"\n        try:\n            # 获取匹配的通知规则\n            rules = NotificationRule.query.filter(\n                NotificationRule.trigger_event == event_type,\n                NotificationRule.is_active == True\n            ).all()\n            \n            for rule in rules:\n                self._process_rule(rule, record_id, context)\n                \n        except Exception as e:\n            logger.error(f'Notification trigger error for {event_type}: {str(e)}')\n    \n    def _process_rule(self, rule: NotificationRule, record_id: int, context: Dict[str, Any]):\n        \"\"\"处理通知规则\"\"\"\n        try:\n            for action in rule.actions:\n                target_users = self._get_target_users(action, context)\n                \n                for user in target_users:\n                    self._send_notifications_to_user(rule, action, user, record_id, context)\n                    \n        except Exception as e:\n            logger.error(f'Rule processing error for rule {rule.id}: {str(e)}')\n    \n    def _get_target_users(self, action, context: Dict[str, Any]) -> List[User]:\n        \"\"\"获取目标用户列表\"\"\"\n        users = []\n        \n        try:\n            if action.action_type == 'NOTIFY_USER':\n                user = User.query.get(int(action.target_identifier))\n                if user and user.is_active:\n                    users.append(user)\n            \n            elif action.action_type == 'NOTIFY_GROUP':\n                from app.models import Group\n                group = Group.query.get(int(action.target_identifier))\n                if group:\n                    users.extend([user for user in group.members if user.is_active])\n            \n            elif action.action_type == 'NOTIFY_ROLE':\n                from app.models import Role\n                role = Role.query.get(int(action.target_identifier))\n                if role:\n                    users.extend([user for user in role.users if user.is_active])\n            \n            elif action.action_type == 'NOTIFY_ASSIGNEE':\n                # 特殊处理：通知事件分配人\n                incident = context.get('incident')\n                if incident and incident.assignee:\n                    users.append(incident.assignee)\n            \n            elif action.action_type == 'NOTIFY_REPORTER':\n                # 特殊处理：通知事件报告人\n                incident = context.get('incident')\n                if incident and incident.reporter:\n                    users.append(incident.reporter)\n                    \n        except Exception as e:\n            logger.error(f'Error getting target users: {str(e)}')\n        \n        return users\n    \n    def _send_notifications_to_user(\n        self,\n        rule: NotificationRule,\n        action,\n        user: User,\n        record_id: int,\n        context: Dict[str, Any]\n    ):\n        \"\"\"向用户发送通知\"\"\"\n        try:\n            # 获取用户的通知偏好\n            user_preferences = {}\n            for pref in user.notification_preferences:\n                user_preferences[pref.channel_type] = pref.is_enabled\n            \n            # 按优先级发送通知\n            channel_priority = action.channel_priority\n            \n            for channel_type in channel_priority:\n                # 检查用户是否启用了该渠道\n                if not user_preferences.get(channel_type, True):\n                    continue\n                \n                # 获取模板\n                template = NotificationTemplate.query.filter(\n                    NotificationTemplate.trigger_event == rule.trigger_event,\n                    NotificationTemplate.channel_type == channel_type,\n                    NotificationTemplate.is_active == True\n                ).first()\n                \n                if not template:\n                    continue\n                \n                # 发送通知\n                self._send_notification(\n                    template, user, record_id, context, rule.id\n                )\n                \n                # 对于P0级事件，使用语音电话时需要升级策略\n                if (channel_type == 'VOICE_CALL' and \n                    context.get('incident') and \n                    context['incident'].priority == 'Critical'):\n                    self._handle_escalation(template, user, record_id, context)\n                \n        except Exception as e:\n            logger.error(f'Error sending notification to user {user.id}: {str(e)}')\n    \n    def _send_notification(\n        self,\n        template: NotificationTemplate,\n        user: User,\n        record_id: int,\n        context: Dict[str, Any],\n        rule_id: int = None\n    ):\n        \"\"\"发送单个通知\"\"\"\n        try:\n            # 确定目标地址\n            if template.channel_type == 'EMAIL':\n                target = user.email\n            elif template.channel_type == 'SMS':\n                target = user.phone_number\n                if not target:\n                    logger.warning(f'User {user.id} has no phone number for SMS')\n                    return\n            elif template.channel_type == 'VOICE_CALL':\n                target = user.phone_number\n                if not target:\n                    logger.warning(f'User {user.id} has no phone number for voice call')\n                    return\n            else:\n                target = user.username  # 对于webhook类型\n            \n            # 渲染模板\n            subject = ''\n            if template.subject_template:\n                subject = self.notification_service.render_template(\n                    template.subject_template, context\n                )\n            \n            content = self.notification_service.render_template(\n                template.body_template, context\n            )\n            \n            # 发送通知\n            result = self.notification_service.send_notification(\n                channel_type=template.channel_type,\n                to=target,\n                subject=subject,\n                content=content,\n                tts_voice=template.tts_voice,\n                play_times=template.play_times,\n                timeout_sec=template.timeout_sec\n            )\n            \n            # 记录日志\n            log = NotificationLog(\n                rule_id=rule_id,\n                template_id=template.id,\n                trigger_event=template.trigger_event,\n                trigger_record_id=record_id,\n                target_user_id=user.id,\n                channel_type=template.channel_type,\n                status='SUCCESS' if result['status'] == 'SUCCESS' else 'FAILED',\n                request_content=json.dumps({\n                    'to': target,\n                    'subject': subject,\n                    'content': content\n                }),\n                response_content=json.dumps(result),\n                external_id=result.get('external_id'),\n                call_duration=result.get('call_duration'),\n                call_status=result.get('call_status')\n            )\n            \n            db.session.add(log)\n            db.session.commit()\n            \n            logger.info(\n                f'Notification sent: {template.channel_type} to user {user.id} '\n                f'for event {template.trigger_event}'\n            )\n            \n        except Exception as e:\n            logger.error(f'Notification sending error: {str(e)}')\n            db.session.rollback()\n    \n    def _handle_escalation(\n        self,\n        template: NotificationTemplate,\n        user: User,\n        record_id: int,\n        context: Dict[str, Any]\n    ):\n        \"\"\"处理语音电话升级策略\"\"\"\n        # 这里可以实现升级逻辑\n        # 例如：如果30秒内没有确认，呼叫团队负责人\n        # 实际实现需要结合外部语音服务的回调机制\n        logger.info(f'Escalation policy triggered for user {user.id}')\n\n# 全局通知触发器实例\nnotification_trigger = NotificationTrigger()\n\n# 事件处理函数\ndef handle_incident_created(incident: Incident):\n    \"\"\"处理事件创建通知\"\"\"\n    context = {\n        'incident': incident,\n        'system_name': '事件管理平台'\n    }\n    notification_trigger.trigger_event('incident.created', incident.id, context)\n\ndef handle_incident_assigned(incident: Incident, old_assignee_id: int):\n    \"\"\"处理事件分配通知\"\"\"\n    context = {\n        'incident': incident,\n        'old_assignee_id': old_assignee_id,\n        'system_name': '事件管理平台'\n    }\n    notification_trigger.trigger_event('incident.assigned', incident.id, context)\n\ndef handle_incident_status_changed(incident: Incident, old_status: str):\n    \"\"\"处理事件状态变更通知\"\"\"\n    context = {\n        'incident': incident,\n        'old_status': old_status,\n        'system_name': '事件管理平台'\n    }\n    notification_trigger.trigger_event('incident.status_changed', incident.id, context)\n\ndef handle_problem_created(problem: Problem):\n    \"\"\"处理故障创建通知\"\"\"\n    context = {\n        'problem': problem,\n        'system_name': '事件管理平台'\n    }\n    notification_trigger.trigger_event('problem.created', problem.id, context)\n\ndef handle_approval_submitted(approval):\n    \"\"\"处理审批提交通知\"\"\"\n    context = {\n        'approval': approval,\n        'problem': approval.problem,\n        'requester': approval.requester,\n        'system_name': '事件管理平台'\n    }\n    notification_trigger.trigger_event('approval.submitted', approval.id, context)\n\ndef handle_approval_approved(approval):\n    \"\"\"处理审批通过通知\"\"\"\n    context = {\n        'approval': approval,\n        'problem': approval.problem,\n        'requester': approval.requester,\n        'system_name': '事件管理平台'\n    }\n    notification_trigger.trigger_event('approval.approved', approval.id, context)\n\ndef handle_approval_rejected(approval):\n    \"\"\"处理审批拒绝通知\"\"\"\n    context = {\n        'approval': approval,\n        'problem': approval.problem,\n        'requester': approval.requester,\n        'system_name': '事件管理平台'\n    }\n    notification_trigger.trigger_event('approval.rejected', approval.id, context)"